<!doctype html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>Belha'li</title>
	<meta name="description" content="The hush between the frogs.">
	<meta name="author" content="Rue">

	<meta property="og:title" content="Belha'li Black-toes">
	<meta property="og:type" content="website">
	<meta name="color-scheme" content="light only">
	<meta property="og:description" content="The hush between the frogs.">

	<link rel="apple-touch-icon" sizes="180x180" href="/img/icons/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/img/icons/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/img/icons/favicon-16x16.png">
	<link rel="manifest" href="/img/icons/site.webmanifest">
	<link rel="mask-icon" href="/img/icons/safari-pinned-tab.svg" color="#5bbad5">
	<link rel="shortcut icon" href="/img/icons/favicon.ico">
	<meta name="msapplication-TileColor" content="#603cba">
	<meta name="msapplication-config" content="/img/icons/browserconfig.xml">
	<meta name="theme-color" content="#ffffff">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Bad+Script&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Oswald:wght@200;300;400;500;600;700&family=PT+Sans+Narrow:wght@400;700&family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=Amatic+SC:wght@400;700&display=swap" rel="stylesheet">


	<link id="dynamic-css" rel="stylesheet" href="css/styles.css">
	<script>
		const link = document.getElementById('dynamic-css');
		const timestamp = new Date().getTime();
		link.href = `css/styles.css?v=${timestamp}`;
	</script>
	<script src="https://code.jquery.com/jquery-3.6.1.js" integrity="sha256-3zlB5s2uwoUzrXK3BT7AX3FyvojsraNFxCc2vC/7pNI=" crossorigin="anonymous"></script>
	<script type="text/javascript">
		$(document).ready(function(){

			const overlay = document.getElementById('map-overlay');
			requestAnimationFrame(() => {
			  overlay.classList.add('animate');

			  setTimeout(() => {
			    overlay.classList.remove('hidden');
			  }, 50);
			});


			$('#map-overlay .sketch').click(function(){
				var classList = $(this).attr("class");
				var classArr = classList.split(/\s+/);
				var targetContainer = $('.container#' + classArr[1]);

				// Fade out current containers
				$('.container.main, .container.active').fadeOut(1000).promise().done(function(){
				// Show the target container after fade out completes
					targetContainer.css('display', 'flex').addClass('active').hide().fadeIn(1500).promise().done(function(){
						const overlay = document.getElementById('map-overlay');
						// Remove active class to slide map out
						overlay.classList.remove('active');
					});
				});
			});
		});

	</script>
</head>

<body> <!-- debug 5 -->
	<div id="map-container" style="position: relative;">
		<div id="map-overlay" class="parchment hidden">
			<svg id="map-lines" width="100%" height="100%" style="position:absolute; top:0; left:0; z-index:100000;"></svg>
			<img class="sketch bones" src="img/bones.png?v=2">
			<img class="sketch cards" src="img/cards.png?v=2">
			<img class="sketch dreamcatcher" src="img/dreamcatcher.png?v=2">
			<img class="sketch paths" src="img/paths.png?v=2">
		</div>
	</div>
	<div id="firefly-container"></div>
	<div class="container main">
		<a href="https://michael-handt.com/work" target="_blank" class="credit">Oil paintings by Michael Handt</a>
		<h1><span class="text"></span>
		"This place hasn't been silent since he learned to listen."</h1>
		<button style="display: none;" id="show-map-btn">Test</button>
		<button style="display: none;" id="close-map-btn">Test</button>
	</div>
	<div class="container" id="bones">
		<div class="quote-overlay"></div>
		<h1 class="topHeader">"Are you lost? The soil remembers your name."</h1>
		<div class="middleQuotes">
			<h1 id="craniumQuote">"The moors gorged on her body. He crawled from her mouth."</h1>
			<h1 id="armQuote">"He sees where it clots. He pulls the sickness out like a thread."</h1>
			<h1 id="jawQuote">"He laughs too loud. He does not look you in the eye."</h1>
			<h1 id="femurQuote">"He carries her weight in silence. It bows him."</h1>
			<h1 id="spineQuote">"He speaks softly to the dead. They're the only ones who listen."</h1>
		</div>
		<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1920 1500">
			<g id="Bg" class="svg-layer bg-layer">
				<image id="Bg-2" data-name="Bg" width="1920" height="1500" xlink:href="img/bg4.png"/>
			</g>
			<g id="Bones">
				<g class="jitter-wrapper" transform="translate(1619 1117)" data-depth="0.9">
					<image id="Jaw" class="bone" width="78" height="49" xlink:href="img/marrow1.png" />
				</g>
				<g class="jitter-wrapper" transform="translate(224 785)" data-depth="1.2">
					<image id="arm" class="bone" width="127" height="202" xlink:href="img/marrow2.png" />
				</g>
				<g class="jitter-wrapper" transform="translate(1141 717)" data-depth="0.8">
					<image id="Femur" class="bone" width="89" height="121" xlink:href="img/marrow3.png" />
				</g>
				<g class="jitter-wrapper" transform="translate(456 605)" data-depth="1.1">
					<image id="Spine" class="bone" width="71" height="116" xlink:href="img/marrow4.png" />
				</g>
				<g class="jitter-wrapper" transform="translate(1508 905)" data-depth="1.0">
					<image id="Cranium" class="bone" width="97" height="113" xlink:href="img/marrow5.png" />
				</g>
			</g>
			<g id="Dirt_overlay" class="svg-layer dirt-layer" data-name="Dirt overlay">
				<image width="1920" height="1500" xlink:href="img/grass.png?rev=2"/>
			</g>
		</svg>
	</div>
	<div class="container" id="cards">
	</div>
	<div class="container" id="dreamcatcher">
	</div>
	<div class="container" id="paths">
	</div>
	<script type="text/javascript">
		class TextScramble {
			constructor(el) {
				this.el = el
				this.chars = 'ᚠᚢᚦᚨᚱᛉᛟᛞᛊᛇᚹᛒᛏ'
				this.update = this.update.bind(this)
			}
			setText(newText) {
				const oldText = this.el.innerText
				const length = Math.max(oldText.length, newText.length)
				const promise = new Promise((resolve) => this.resolve = resolve)
				this.queue = []
				for (let i = 0; i < length; i++) {
					const from = oldText[i] || ''
					const to = newText[i] || ''
					const start = Math.floor(Math.random() * 40)
					const end = start + Math.floor(Math.random() * 40)
					this.queue.push({ from, to, start, end })
				}
				cancelAnimationFrame(this.frameRequest)
				this.frame = 0
				this.update()
				return promise
			}
			update() {
				let output = ''
				let complete = 0
				for (let i = 0, n = this.queue.length; i < n; i++) {
					let { from, to, start, end, char } = this.queue[i]
					if (this.frame >= end) {
						complete++
						output += to
					} else if (this.frame >= start) {
						if (!char || Math.random() < 0.28) {
							char = this.randomChar()
							this.queue[i].char = char
						}
						output += `<span class="dud">${char}</span>`
					} else {
						output += from
					}
				}
				this.el.innerHTML = output
				if (complete === this.queue.length) {
					this.resolve()
				} else {
					this.frameRequest = requestAnimationFrame(this.update)
					this.frame++
				}
			}
			randomChar() {
				return this.chars[Math.floor(Math.random() * this.chars.length)]
			}
		}

		const phrases = [
			'Black-Toes',
			'Witch of the Fifth Gut',
			'Scarred Wretch',
			'Bleeds-the-Dusk',
			'Grave-Licker',
		]

		const el = document.querySelector('.text')
		const fx = new TextScramble(el)

		let counter = 0
		const next = () => {
			fx.setText(phrases[counter]).then(() => {
				setTimeout(next, 800)
			})
			counter = (counter + 1) % phrases.length
		}

		next()
	</script>
	<script>
		const NUM_FIREFLIES = 30;
	  const MIN_DISTANCE = 50; // Minimum distance between fireflies

	  const container = document.getElementById("firefly-container");
	  const usedPositions = [];

	  function getRandomPosition() {
	  	const maxWidth = window.innerWidth;
	  	const maxHeight = window.innerHeight;
	  	let x, y;
	  	let attempts = 0;

	  	do {
	  		x = Math.random() * maxWidth;
	  		y = Math.random() * maxHeight;
	  		attempts++;
	  	} while (
	  		usedPositions.some(pos => {
	  			const dx = pos.x - x;
	  			const dy = pos.y - y;
	  			return Math.sqrt(dx * dx + dy * dy) < MIN_DISTANCE;
	  		}) && attempts < 50
	  		);

	  	usedPositions.push({ x, y });
	  	return { x, y };
	  }

	  for (let i = 0; i < NUM_FIREFLIES; i++) {
	  	const firefly = document.createElement("div");
	  	firefly.classList.add("firefly");

	  	const { x, y } = getRandomPosition();

	    // Random scale (size variation)
	  	const scale = 0.6 + Math.random() * 1.2;

	    // Random durations and delays
	  	const flickerDuration = 1.5 + Math.random() * 1.5;
	  	const wanderDuration = 15 + Math.random() * 10;
	  	const delay = Math.random() * 5;

	  	firefly.style.top = `${y}px`;
	  	firefly.style.left = `${x}px`;
	  	firefly.style.transform = `scale(${scale})`;

	  	firefly.style.animation = `
	      flicker ${flickerDuration.toFixed(2)}s ease-in-out ${delay.toFixed(2)}s infinite,
	      wander ${wanderDuration.toFixed(2)}s ease-in-out ${delay.toFixed(2)}s infinite
	  	`;

	  	container.appendChild(firefly);
	  }
	</script>
	<script>
		const mainContainer = document.querySelector('.container.main');
		const fireflyContainer = document.getElementById('firefly-container');
		const bgLayer = document.querySelector('#Bg');
		const dirtLayer = document.querySelector('#Dirt_overlay');
		const boneWrappers = document.querySelectorAll('.jitter-wrapper');
		const bones = document.querySelectorAll('.bone');

		let targetX = 0;
		let targetY = 0;

// Store original transforms so we preserve base positions
		const bgOriginalTransform = bgLayer ? bgLayer.getAttribute('transform') || '' : '';
		const dirtOriginalTransform = dirtLayer ? dirtLayer.getAttribute('transform') || '' : '';
		const bonesOriginalTransforms = Array.from(boneWrappers).map(wrapper => wrapper.getAttribute('transform') || '');

		document.addEventListener('mousemove', (e) => {
			const { innerWidth, innerHeight } = window;
			const x = (e.clientX / innerWidth - 0.5) * 2;
			const y = (e.clientY / innerHeight - 0.5) * 2;

			targetX = x;
			targetY = y;

  // Glow proximity check for bones
			bones.forEach((bone) => {
				const rect = bone.getBoundingClientRect();
				const boneX = rect.left + rect.width / 2;
				const boneY = rect.top + rect.height / 2;

				const dx = e.clientX - boneX;
				const dy = e.clientY - boneY;
				const distance = Math.sqrt(dx * dx + dy * dy);

				if (distance < 100) {
					bone.classList.add('glow');
      bone.classList.add('jitter'); // add jitter class on wrapper
  } else {
  	bone.classList.remove('glow');
  	bone.classList.remove('jitter');
  }
});
		});

		let bgX = 0;
		let bgY = 0;
		let ffX = 0;
		let ffY = 0;

		function animateParallax() {
  // Smooth interpolation for background (CSS background of main container)
			bgX += (targetX * 10 - bgX) * 0.05;
			bgY += (targetY * 10 - bgY) * 0.05;

  // Smooth interpolation for fireflies
			ffX += (targetX * 4 - ffX) * 0.04;
			ffY += (targetY * 4 - ffY) * 0.04;

  // Apply background parallax (CSS background image)
			mainContainer.style.backgroundPosition = `${50 + bgX}% ${50 + bgY}%`;

  // Apply fireflies parallax
			fireflyContainer.style.transform = `translate(${ffX}px, ${ffY}px)`;

  // Parallax for SVG background group (#Bg) — preserve original transform
			if (bgLayer) {
				const bgOffsetX = targetX * 2;
				const bgOffsetY = targetY * 2;
				bgLayer.setAttribute('transform', `${bgOriginalTransform} translate(${bgOffsetX}, ${bgOffsetY})`);
			}

  // Parallax for dirt overlay (#Dirt_overlay) — preserve original transform
			if (dirtLayer) {
				const dirtOffsetX = targetX * 1.5;
				const dirtOffsetY = targetY * 1.5;
				dirtLayer.setAttribute('transform', `${dirtOriginalTransform} translate(${dirtOffsetX}, ${dirtOffsetY})`);
			}

  // Parallax and jitter for bones wrappers — preserve original transform
			boneWrappers.forEach((wrapper, i) => {
				const depth = parseFloat(wrapper.dataset.depth) || 1;
				const offsetX = targetX * 10 * depth;
				const offsetY = targetY * 10 * depth;
				const original = bonesOriginalTransforms[i];
				wrapper.setAttribute('transform', `${original} translate(${offsetX}, ${offsetY})`);
			});

			requestAnimationFrame(animateParallax);
		}

		animateParallax();
	</script>
	<script>
	// Show the map when button is clicked
		document.getElementById('show-map-btn').addEventListener('click', function () {
			const overlay = document.getElementById('map-overlay');

		// Add active class to slide map into view
			overlay.classList.add('active');

		// Lock background scroll
			document.body.style.overflow = 'hidden';

		// Wait for the animation to finish, then draw lines
			setTimeout(drawDottedLines, 900);
		});

	// Close the map
		document.getElementById('close-map-btn').addEventListener('click', function () {
			const overlay = document.getElementById('map-overlay');

		// Remove active class to slide map out
			overlay.classList.remove('active');

		// Re-enable background scroll
			document.body.style.overflow = '';
		});

		function drawDottedLines() {
			const sketches = document.querySelectorAll('#map-overlay .sketch');
			const svg = document.getElementById('map-lines');
	  svg.innerHTML = ''; // Clear previous paths and dots

	  const parentRect = document.getElementById('map-overlay').getBoundingClientRect();
	  const trimFraction = 0.01; // Trim 10% from each end

	  const positions = Array.from(sketches).map(img => {
	  	const rect = img.getBoundingClientRect();
	  	return {
	  		x: rect.left + rect.width / 2 - parentRect.left,
	  		y: rect.top + rect.height / 2 - parentRect.top
	  	};
	  });

	  for (let i = 0; i < positions.length - 1; i++) {
	  	const p1 = positions[i];
	  	const p2 = positions[i + 1];

	  	const dx = p2.x - p1.x;
	  	const dy = p2.y - p1.y;
	  	const length = Math.hypot(dx, dy);
	  	const ux = dx / length;
	  	const uy = dy / length;

	  	const trimAmount = length * trimFraction;

	  	const start = {
	  		x: p1.x + ux * trimAmount,
	  		y: p1.y + uy * trimAmount
	  	};
	  	const end = {
	  		x: p2.x - ux * trimAmount,
	  		y: p2.y - uy * trimAmount
	  	};

	  	const segments = 3;
	  	const points = [start];

	  	for (let j = 1; j < segments; j++) {
	  		const t = j / segments;
	  		const x = start.x + dx * t;
	  		const y = start.y + dy * t;

	      // Instead of random offset in all directions, first move vertically above the target
	  		let offsetX = 0;
	  		let offsetY = 0;

	  		if (j === segments - 1) {
	        // Last intermediate point: go above target
	        offsetY = -100; // adjust vertical height above sketch
	    } else {
	        // Optional: small random wiggle for earlier points
	    	offsetX = (Math.random() - 0.5) * 50;
	    	offsetY = (Math.random() - 0.5) * 50;
	    }

	    points.push({
	    	x: x + offsetX,
	    	y: y + offsetY
	    });
	}

	points.push(end);

	animateDotsOnCurve(svg, points);
}
}

function animateDotsOnCurve(svg, points, totalDots = 30, interval = 30) {
	  // Build curve from points using quadratic segments
	const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
	let d = `M ${points[0].x},${points[0].y}`;
	for (let j = 1; j < points.length - 1; j++) {
		const cp = points[j - 1];
		const pt = points[j];
		const mx = (cp.x + pt.x) / 2;
		const my = (cp.y + pt.y) / 2;
		d += ` Q ${cp.x},${cp.y} ${mx},${my}`;
	}

// Final segment: go to actual last point
	const penultimate = points[points.length - 2];
	const last = points[points.length - 1];
	d += ` Q ${penultimate.x},${penultimate.y} ${last.x},${last.y}`;


	path.setAttribute("d", d);
	path.setAttribute("fill", "none");
	  path.setAttribute("stroke", "none"); // Hide actual path
	  svg.appendChild(path);

	  // Get points along the path using getPointAtLength
	  const pathLength = path.getTotalLength();

	  let i = 0;
	  const drawNextDot = () => {
	  	if (i >= totalDots) return;

	  	const point = path.getPointAtLength((i / totalDots) * pathLength);
	  	const dot = document.createElementNS("http://www.w3.org/2000/svg", "circle");
	  	dot.setAttribute("cx", point.x);
	  	dot.setAttribute("cy", point.y);
	  	dot.setAttribute("r", 2);
	  	dot.setAttribute("fill", "#3a2f28");
	  	svg.appendChild(dot);

	  	i++;
	  	setTimeout(drawNextDot, interval);
	  };

	  drawNextDot();
	}

	let resizeTimeout;
	window.addEventListener('resize', () => {
		clearTimeout(resizeTimeout);
		resizeTimeout = setTimeout(() => {
			drawDottedLines();
	  }, 150); // delay in ms
	});

</script>
<script>
	const bones2 = document.querySelectorAll('.bone');
	  const radius = 100; // Distance (in px) for glow activation

	  document.addEventListener('mousemove', (e) => {
	  	bones2.forEach(bone => {
	  		const rect = bone.getBoundingClientRect();
	  		const boneX = rect.left + rect.width / 2;
	  		const boneY = rect.top + rect.height / 2;

	  		const dx = e.clientX - boneX;
	  		const dy = e.clientY - boneY;
	  		const distance = Math.sqrt(dx * dx + dy * dy);

	  		if (distance < radius) {
	  			bone.classList.add('glow');
	  		} else {
	  			bone.classList.remove('glow');
	  		}
	  	});
	  });
	  const quotes = document.querySelectorAll('.middleQuotes h1');
	  const overlay = document.querySelector('.quote-overlay');

	  let selectedBone = null;

	  const topHeader = document.querySelector('.topHeader');

	  function closeQuote() {
	  	if (selectedBone) {
	  		const quoteId = `${selectedBone.id.toLowerCase()}Quote`;
	  		const quote = document.getElementById(quoteId);
	  		quote.classList.remove('active');
	  		selectedBone.classList.remove('selected', 'glow');
	  		const wrapper = selectedBone.parentElement;
	  		if (wrapper.classList.contains('jitter')) {
	  			wrapper.classList.remove('paused');
	  		}
	  		selectedBone = null;
	  		overlay.classList.remove('active');

		    // Show top header again
	  		topHeader.classList.remove('hidden');
	  	}
	  }

	  bones2.forEach(bone => {
	  	bone.addEventListener('click', (e) => {
	  		e.stopPropagation();

	  		const boneId = bone.id.toLowerCase();
	  		const quoteId = `${boneId}Quote`;
	  		const quote = document.getElementById(quoteId);

	  		if (selectedBone === bone) {
	  			closeQuote();
	  		} else {
	  			closeQuote();

	  			quote.classList.add('active');
	  			bone.classList.add('selected', 'glow');
	  			const wrapper = bone.parentElement;
	  			if (wrapper.classList.contains('jitter')) {
	  				wrapper.classList.add('paused');
	  			}
	  			selectedBone = bone;
	  			overlay.classList.add('active');

		      // Hide top header when overlay opens
	  			topHeader.classList.add('hidden');
	  		}
	  	});
	  });

	  overlay.addEventListener('click', () => {
	  	closeQuote();
	  });

	  document.addEventListener('click', (e) => {
	  	if (!e.target.closest('.bone') && !e.target.closest('.quote-overlay')) {
	  		closeQuote();
	  	}
	  });
	</script>
</body>
</html>