<!doctype html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<title>Belha'li</title>
	<meta name="description" content="The hush between the frogs.">
	<meta name="author" content="Rue">

	<meta property="og:title" content="Belha'li Black-toes">
	<meta property="og:type" content="website">
	<meta name="color-scheme" content="light only">
	<meta property="og:description" content="The hush between the frogs.">

	<link rel="apple-touch-icon" sizes="180x180" href="/img/icons/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/img/icons/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/img/icons/favicon-16x16.png">
	<link rel="manifest" href="/img/icons/site.webmanifest">
	<link rel="mask-icon" href="/img/icons/safari-pinned-tab.svg" color="#5bbad5">
	<link rel="shortcut icon" href="/img/icons/favicon.ico">
	<meta name="msapplication-TileColor" content="#603cba">
	<meta name="msapplication-config" content="/img/icons/browserconfig.xml">
	<meta name="theme-color" content="#ffffff">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Bad+Script&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Oswald:wght@200;300;400;500;600;700&family=PT+Sans+Narrow:wght@400;700&family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=Amatic+SC:wght@400;700&display=swap" rel="stylesheet">


	<link id="dynamic-css" rel="stylesheet" href="css/styles.css">
	<script>
	  const link = document.getElementById('dynamic-css');
	  const timestamp = new Date().getTime();
	  link.href = `css/styles.css?v=${timestamp}`;
	</script>
	<script src="https://code.jquery.com/jquery-3.6.1.js" integrity="sha256-3zlB5s2uwoUzrXK3BT7AX3FyvojsraNFxCc2vC/7pNI=" crossorigin="anonymous"></script>
	<script type="text/javascript">
		$(document).ready(function(){
			$('.main .column').click(function(){
				var classList = $(this).attr("class");
				var classArr = classList.split(/\s+/);
				$('.other .row').hide();
				$('.row.'+ classArr[1]).css('display', 'flex');
				$('.container.main').fadeOut(1000).promise().done(function(){
					$('.container.other').fadeIn(1500);
				});
			});
			$('.returnBtn').click(function(){
				$('.other .row').fadeOut(1000).promise().done(function(){
					$('.container.other').hide();
					$('.container.main').fadeIn(1500);
				});
			});
		});
	</script>
</head>

<body> <!-- debug 5 -->
	<div id="map-container" style="position: relative;">
		<div id="map-overlay" class="parchment">
			<div id="map-overlay">
			  <svg id="map-lines" width="100%" height="100%" 
			       style="position:absolute; top:0; left:0; z-index:100000;"></svg>
			  <svg id="map-labels" width="100%" height="100%" 
			       style="position:absolute; top:0; left:0; z-index:100001; pointer-events:none;"></svg>
			<img class="sketch bones" src="img/bones.png">
			<img class="sketch cards" src="img/cards.png">
			<img class="sketch dreamcatcher" src="img/dreamcatcher.png">
			<img class="sketch paths" src="img/paths.png">
		</div>
	</div>
	<div id="firefly-container"></div>
	<div class="container main">
		<a href="https://michael-handt.com/work" target="_blank" class="credit">Oil paintings by Michael Handt</a>
		<h1><span class="text"></span>
		"This place hasn't been silent since he learned to listen."</h1>
		<button style="display: none;" id="show-map-btn">Test</button>
		<button style="display: none;" id="close-map-btn">Test</button>
	</div>
	<div class="container other">
		<div class="row about">
		</div>
		<div class="row perceptions" style="display:flex;justify-content: center;">
		</div>
		<div class="row gallery" style="display:flex;justify-content: center;">
		</div>
		<div class="row ooc" style="display:flex;justify-content: center;">
		</div>
	</div>
	<script type="text/javascript">
		class TextScramble {
			constructor(el) {
				this.el = el
				this.chars = 'ᚠᚢᚦᚨᚱᛉᛟᛞᛊᛇᚹᛒᛏ'
				this.update = this.update.bind(this)
			}
			setText(newText) {
				const oldText = this.el.innerText
				const length = Math.max(oldText.length, newText.length)
				const promise = new Promise((resolve) => this.resolve = resolve)
				this.queue = []
				for (let i = 0; i < length; i++) {
					const from = oldText[i] || ''
					const to = newText[i] || ''
					const start = Math.floor(Math.random() * 40)
					const end = start + Math.floor(Math.random() * 40)
					this.queue.push({ from, to, start, end })
				}
				cancelAnimationFrame(this.frameRequest)
				this.frame = 0
				this.update()
				return promise
			}
			update() {
				let output = ''
				let complete = 0
				for (let i = 0, n = this.queue.length; i < n; i++) {
					let { from, to, start, end, char } = this.queue[i]
					if (this.frame >= end) {
						complete++
						output += to
					} else if (this.frame >= start) {
						if (!char || Math.random() < 0.28) {
							char = this.randomChar()
							this.queue[i].char = char
						}
						output += `<span class="dud">${char}</span>`
					} else {
						output += from
					}
				}
				this.el.innerHTML = output
				if (complete === this.queue.length) {
					this.resolve()
				} else {
					this.frameRequest = requestAnimationFrame(this.update)
					this.frame++
				}
			}
			randomChar() {
				return this.chars[Math.floor(Math.random() * this.chars.length)]
			}
		}

		const phrases = [
			'Black-Toes',
			'Witch of the Fifth Gut',
			'Blood-in-the-Water',
			'Bleeds-the-Dusk',
			'Grave-Licker',
			]

		const el = document.querySelector('.text')
		const fx = new TextScramble(el)

		let counter = 0
		const next = () => {
			fx.setText(phrases[counter]).then(() => {
				setTimeout(next, 800)
			})
			counter = (counter + 1) % phrases.length
		}

		next()
	</script>
	<script>
	  const NUM_FIREFLIES = 30;
	  const MIN_DISTANCE = 50; // Minimum distance between fireflies

	  const container = document.getElementById("firefly-container");
	  const usedPositions = [];

	  function getRandomPosition() {
	    const maxWidth = window.innerWidth;
	    const maxHeight = window.innerHeight;
	    let x, y;
	    let attempts = 0;

	    do {
	      x = Math.random() * maxWidth;
	      y = Math.random() * maxHeight;
	      attempts++;
	    } while (
	      usedPositions.some(pos => {
	        const dx = pos.x - x;
	        const dy = pos.y - y;
	        return Math.sqrt(dx * dx + dy * dy) < MIN_DISTANCE;
	      }) && attempts < 50
	    );

	    usedPositions.push({ x, y });
	    return { x, y };
	  }

	  for (let i = 0; i < NUM_FIREFLIES; i++) {
	    const firefly = document.createElement("div");
	    firefly.classList.add("firefly");

	    const { x, y } = getRandomPosition();

	    // Random scale (size variation)
	    const scale = 0.6 + Math.random() * 1.2;

	    // Random durations and delays
	    const flickerDuration = 1.5 + Math.random() * 1.5;
	    const wanderDuration = 15 + Math.random() * 10;
	    const delay = Math.random() * 5;

	    firefly.style.top = `${y}px`;
	    firefly.style.left = `${x}px`;
	    firefly.style.transform = `scale(${scale})`;

	    firefly.style.animation = `
	      flicker ${flickerDuration.toFixed(2)}s ease-in-out ${delay.toFixed(2)}s infinite,
	      wander ${wanderDuration.toFixed(2)}s ease-in-out ${delay.toFixed(2)}s infinite
	    `;

	    container.appendChild(firefly);
	  }
	</script>
	<script>
	  const mainContainer = document.querySelector('.container.main');
	  const fireflyContainer = document.getElementById('firefly-container');

	  let targetX = 0;
	  let targetY = 0;
	  let bgX = 0;
	  let bgY = 0;
	  let ffX = 0;
	  let ffY = 0;

	  document.addEventListener('mousemove', (e) => {
	    const { innerWidth, innerHeight } = window;
	    const x = (e.clientX / innerWidth - 0.5) * 2;
	    const y = (e.clientY / innerHeight - 0.5) * 2;

	    targetX = x;
	    targetY = y;
	  });

	  function animateParallax() {
	    // Smooth interpolation
	    bgX += (targetX * 10 - bgX) * 0.05;
	    bgY += (targetY * 10 - bgY) * 0.05;

	    ffX += (targetX * 4 - ffX) * 0.04; // smaller scale for fireflies
	    ffY += (targetY * 4 - ffY) * 0.04;

	    // Apply to background
	    mainContainer.style.backgroundPosition = `${50 + bgX}% ${50 + bgY}%`;

	    // Apply to firefly container using transform (better performance)
	    fireflyContainer.style.transform = `translate(${ffX}px, ${ffY}px)`;

	    requestAnimationFrame(animateParallax);
	  }

	  animateParallax();
	</script>
	<script>
	// Show the map when button is clicked
	document.getElementById('show-map-btn').addEventListener('click', function () {
		const overlay = document.getElementById('map-overlay');

		// Add active class to slide map into view
		overlay.classList.add('active');

		// Lock background scroll
		document.body.style.overflow = 'hidden';

		// Wait for the animation to finish, then draw lines
		setTimeout(drawDottedLines, 900);
	});

	// Close the map
	document.getElementById('close-map-btn').addEventListener('click', function () {
		const overlay = document.getElementById('map-overlay');

		// Remove active class to slide map out
		overlay.classList.remove('active');

		// Re-enable background scroll
		document.body.style.overflow = '';
	});

	document.addEventListener("DOMContentLoaded", () => {
	  const linesSVG = document.getElementById("map-lines");
	  const labelsSVG = document.getElementById("map-labels");

	  function getOverlayRect() {
	    return document.getElementById("map-overlay").getBoundingClientRect();
	  }

	  function getCenter(el, overlayRect) {
	    const rect = el.getBoundingClientRect();
	    return {
	      x: rect.left - overlayRect.left + rect.width / 2,
	      y: rect.top - overlayRect.top + rect.height / 2
	    };
	  }

	  function drawCurvedLineWithLabel(id, x1, y1, x2, y2, label = "") {
	    const midX = (x1 + x2) / 2;
	    const midY = Math.min(y1, y2) - 80; // arc bow height
	    const d = `M ${x1} ${y1} Q ${midX} ${midY} ${x2} ${y2}`;

	    // --- Path (dotted, animated) ---
	    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
	    path.setAttribute("id", `path-${id}`);
	    path.setAttribute("d", d);
	    path.setAttribute("fill", "none");
	    path.setAttribute("stroke", "#3a2f28");
	    path.setAttribute("stroke-width", "2");
	    path.setAttribute("stroke-dasharray", "6 6");

	    const length = path.getTotalLength();
	    path.style.strokeDasharray = length;
	    path.style.strokeDashoffset = length;
	    linesSVG.appendChild(path);

	    // animate the line
	    path.getBoundingClientRect(); // force reflow
	    path.style.transition = "stroke-dashoffset 2s ease-out";
	    path.style.strokeDashoffset = "0";

	    // --- Label (handwriting effect) ---
	    if (label) {
	      const textPath = document.createElementNS("http://www.w3.org/2000/svg", "textPath");
	      textPath.setAttribute("href", `#path-${id}`);
	      textPath.setAttribute("startOffset", "50%");
	      textPath.textContent = label;

	      const textEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
	      textEl.setAttribute("font-family", "'Bad Script', cursive");
	      textEl.setAttribute("font-size", "20");
	      textEl.setAttribute("fill", "none");
	      textEl.setAttribute("stroke", "#3a2f28");
	      textEl.setAttribute("stroke-width", "1px");
	      textEl.setAttribute("text-anchor", "middle");
	      textEl.setAttribute("dy", "-5");

	      textEl.appendChild(textPath);
	      labelsSVG.appendChild(textEl);

	      // handwriting animation
	      const textLength = label.length * 12; // rough length
	      textEl.style.strokeDasharray = textLength;
	      textEl.style.strokeDashoffset = textLength;
	      textEl.style.transition = "stroke-dashoffset 2s ease-out 0.3s";
	      requestAnimationFrame(() => {
	        textEl.style.strokeDashoffset = "0";
	      });

	      // fill in after handwriting finishes
	      setTimeout(() => {
	        textEl.setAttribute("fill", "#3a2f28");
	      }, 2300);
	    }
	  }

	  // ---- Hardcoded connections (like your original) ----
	  const connections = [
	    { id: "bones-to-cards", from: "bones", to: "cards", label: "The Crooked Path" },
	    { id: "cards-to-dream", from: "cards", to: "dreamcatcher", label: "Dreamer’s Crossing" },
	    { id: "dream-to-paths", from: "dreamcatcher", to: "paths", label: "The Winding Road" }
	  ];

	  function drawAllConnections() {
	    linesSVG.innerHTML = "";
	    labelsSVG.innerHTML = "";
	    const overlayRect = getOverlayRect();

	    connections.forEach(conn => {
	      const fromEl = document.getElementById(conn.from);
	      const toEl = document.getElementById(conn.to);
	      if (fromEl && toEl) {
	        const p1 = getCenter(fromEl, overlayRect);
	        const p2 = getCenter(toEl, overlayRect);
	        drawCurvedLineWithLabel(conn.id, p1.x, p1.y, p2.x, p2.y, conn.label);
	      }
	    });
	  }

	  // initial draw
	  drawAllConnections();

	  // redraw on resize (with debounce, like original)
	  let resizeTimeout;
	  window.addEventListener("resize", () => {
	    clearTimeout(resizeTimeout);
	    resizeTimeout = setTimeout(drawAllConnections, 300);
	  });
	});

	</script>
</body>
</html>